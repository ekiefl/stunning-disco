import numpy as np
import pandas as pd
import variants.snv as snv
import glob
import os

class TableOperations():
    """
    Instances of this class take the parameter `args` which is a dictionary. An example dictionary could look
    like the following:

    args = {"saav-table":"TIM_barrels",
            "simplify-sample-id-method":"SAR11",
            "columns-to-append":["solvent_accessibility","3_class_structure","8_class_structure","site_rel_entropy","site_entropy"],
            "raptor-repo":"02_raptor_out",
            "genes-of-interest":"genes_TIM_barrels.txt",
            "ss3-structure-confidence":0.66,
            "ss8-structure-confidence":0.5,
            "solvent-accessibility-confidence":0.66,
            "entropy-log-base":np.exp(1),
            "out":"TIM_barrels",
            "pickle":True,
            "dont-save":True}
    """

    def __init__(self,args):

        self.args = args
        A = lambda x: args[x] if x in args else None
        self.saav_table_fname = A("saav-table")
        self.simplify_sample_id_method = A("simplify-sample-id-method")
        self.columns_to_append = A("columns-to-append")
        self.column_suites_to_append = A("column-suites-to-append")
        self.raptor_repo = A("raptor-repo")
        self.gene_filename = A("genes-of-interest")
        self.ss3_confidence = A("ss3-structure-confidence")
        self.ss8_confidence = A("ss8-structure-confidence")
        self.solvent_acc_confidence = A("solvent-accessibility-confidence")
        self.entropy_log_base = A("entropy-log-base")
        self.dont_save = A("dont-save")
        self.out = A("out")
        self.pkl = A("pickle")

    #   loads saav table, loads pkl first (loads faster) if it exists
        if os.path.isfile("{}.pkl".format(os.path.splitext(self.saav_table_fname)[0])):
            self.saav_table = pd.read_pickle("{}.pkl".format(os.path.splitext(self.saav_table_fname)[0]))
        else:
            self.saav_table = snv.load_gene_table(self.saav_table_fname)
            #self.saav_table = self.saav_table.dropna()
            #self.saav_table = snv.filter_by_snv(self.saav_table, filt_quince=True, filt_incgene=False)
            if self.simplify_sample_id_method:
                self.simplify_sample_ids()

    #   store array of samples
        self.sample_list = self.saav_table["sample_id"].unique()

    #   load self.genes_of_interest from self.gene_filename and filter SAAV table to include only these genes
        if self.gene_filename:
            self.genes_of_interest = [x.strip() for x in open(self.gene_filename).readlines()]
            self.filter_table("corresponding_gene_call", self.genes_of_interest)
        else:
            self.genes_of_interest = self.saav_table["corresponding_gene_call"].unique()
        print("genes of interest: {} in total".format(len(self.genes_of_interest)))

    #   makes default logarithm base equal to default if not provided by user
        if not self.entropy_log_base:
            self.entropy_log_base = np.exp(1)
    #   create a list of all the existing methods that append columns
        self.list_of_append_methods = self.get_all_append_methods()
    #   tells the user which columns they have currently appended
        self.previously_added_columns(for_user=True)
    #   make sure everything checks out. remove methods whose columns have already been added
        self.sanity_check()

    def main(self):
        self.add_columns()
        if self.dont_save:
            print("Process finished but you requested it not to be saved.")
        else:
            print("Process finished. Saving.")
            self.save()

    def save(self):
        """
        saves the new SAAV table to the user provided self.out variable. If
        self.pkl == True, the SAAV table will also be saved as a pickle file
        as {self.out}.pkl
        """
        self.saav_table.to_csv(self.out, sep='\t', index=False)
        if self.pkl:
            self.saav_table.to_pickle(os.path.splitext(self.out)[0]+".pkl") 

    def filter_table(self, column, elements):
        """
        This function filters the SAAV table according to single column criteria,
        where column is the column you are filtering by and elements is a list of 
        accepted elements in that column. All other rows are filtered
        """
        self.saav_table = self.saav_table[self.saav_table[column].isin(elements)]

    def add_columns(self):
        for col in self.columns_to_append:
            append_method = getattr(self,"append_"+col)
            append_method()

    def previously_added_columns(self, for_user=False):
        """
        This returns a list of column ids that have already been added to the SAAV table (those that are in 
        addition to the standard output generated by anvi'o). If for_user=True, the function instead prints
        out a list of any added columns and is for the benefit of the user to keep track of changes they
        make to their SAAV table.
        """
        out_of_box = [u'unique_pos_identifier', u'sample_id', u'corresponding_gene_call',
                      u'codon_order_in_gene', u'reference', u'departure_from_reference',
                      u'coverage', u'Ala', u'Arg', u'Asn', u'Asp', u'Cys', u'Gln', u'Glu',
                      u'Gly', u'His', u'Ile', u'Leu', u'Lys', u'Met', u'Phe', u'Pro', u'STP',
                      u'Ser', u'Thr', u'Trp', u'Tyr', u'Val', u'BLOSUM90', u'BLOSUM62',
                      u'competing_aas', u'consensus', u'departure_from_consensus',
                      u'n2n1ratio', u'gene_length']
        added = [col for col in self.saav_table.columns if col not in out_of_box]
        
        if not for_user:
            return added
        else:
            if len(added) == 0:
                print("No columns have been added")
            else:
                print("The following columns are already appended:\n{}".format(added))

    def simplify_sample_ids(self):
        """
        If ad hoc sample_id modifications need to be made for whatever reason, you can define a method
        here for such a purpose. For an example, see the case when simplify_sample_id_method == "SAR11",
        for which this method was first defined.
        """
        if self.simplify_sample_id_method == "SAR11":
            self.saav_table["sample_id"] = self.saav_table["sample_id"].str.replace("SAR11_","")
            self.saav_table["sample_id"] = self.saav_table["sample_id"].str.replace("_BOWTIE2","")
            self.saav_table["cohort"] = self.saav_table["sample_id"].str.split("_",expand=True)[0]
        elif self.simplify_sample_id_method == "placeholder":
            pass
        else:
            raise ValueError("simplify_sample_ids subroutine for simplify_sample_id_method = {} not defined".\
                              format(self.simplify_sample_id_method))

    def append_solvent_accessibility(self):
        """
        RaptorX outputs a {}.all_in_one folder for each sequence it predicts structure for. All
        of these need to be placed into a folder self.raptor_repo. This function incorporates the
        solvent accesibility predictions found in self.raptor_repo/{}.all_in_one/labeling/{}.acc
        by adding one column, "solvent_acc".

        solvent_acc : ["B"=Buried(pACC=1-10), "M"=Medium(pACC=11-40), "E"=Exposed(pACC=41-100), "U"=Unknown]
            pACC is equal to the relative solvent accessibility calculated by DSSP. If the highest confidence
            for the classifications B, M, and E is less than self.solvent_acc_confidence,
            the SAAV is considered U.
        """

        columns = ("codon_order_in_gene","AA","solvent_acc","prob_B","prob_M","prob_E")


        def calc_solv_acc_in_1gene(x):
        #   get gene id of this groupby object, then find path of .ss3 file for that gene
            gene = x["corresponding_gene_call"].values[0]
            solvent_acc_path = glob.glob(os.path.join(self.raptor_repo,"{}.all_in_one".format(gene),"labeling","*.acc"))[0]
        #   load solvent_acc data for gene as pandas DataFrame
            acc = pd.read_csv(solvent_acc_path, skiprows=3, names=columns, delim_whitespace=True)
        #   0 index the raptor results to conform to anvio convention :\
            acc["codon_order_in_gene"] -= 1
        #   add gene column (used to uniquely map acc entries to saav entries)
            acc["corresponding_gene_call"] = gene
        #   if the highest confidence for the 3 classes < self.solvent_acc_confidence, the SAAV is classified as "U" for unknown
            l = [col for col in acc.columns if "prob_" in col]
            acc["solvent_acc"] = acc.apply(lambda row: row["solvent_acc"] if any(row[l] > self.solvent_acc_confidence) else "U", axis = 1)
        #   prob_genewide_X is the total number of AAs in the gene with secondary structure X
            acc["solvent_acc_genewide_B"] = len(acc[acc["solvent_acc"] == "B"])
            acc["solvent_acc_genewide_M"] = len(acc[acc["solvent_acc"] == "M"])
            acc["solvent_acc_genewide_E"] = len(acc[acc["solvent_acc"] == "E"])
            acc["solvent_acc_genewide_U"] = len(acc[acc["solvent_acc"] == "U"])
        #   The `AA` column (1-letter AA code) is redundant, we already have `reference` (3-letter AA code)
        #   prob_X are also dropped to cut down on saav_table_size, but code could be modified to retain them
            acc = acc.drop(["AA"]+l, axis=1)
        #   merge with original dataframe
            return pd.merge(x,acc)

        saav_table_grouped = self.saav_table.groupby("corresponding_gene_call")
        self.saav_table = saav_table_grouped.apply(calc_solv_acc_in_1gene)

    def append_3_class_structure(self):
        """
        RaptorX outputs a {}.all_in_one folder for each sequence it predicts structure for. All
        of these need to be placed into a folder self.raptor_repo. The secondary structure predictions
        for RaptorX are found in self.raptor_repo/{}.all_in_one/labeling/{}.ss3. This function uses
        this information from every gene in self.saav_table to construct 4 new columns:

        ss3 : ["H", "E", "C", "U"]
            The most likely secondary structure. "H" = alpha helix, "E" = beta sheet, "C" = loop, and
            "U" = unknown. We classify the SAAV as "U" whenever the highest confidence score attributed
            to the 3 structures is less than self.prob_confidence.
        prob_genewide_X : integer
            The number of amino acids (not SAAVs--you can count this yourself using the table) in the
            protein that are classified as X.
        """
        
        columns = ("codon_order_in_gene","AA","ss3","prob_H","prob_E","prob_C")

        def calc_ss3_data_in_1gene(x):
        #   get gene id of this groupby object, then find path of .ss3 file for that gene
            gene = x["corresponding_gene_call"].values[0]
            ss3_path = glob.glob(os.path.join(self.raptor_repo,"{}.all_in_one".format(gene),"labeling","*.ss3"))[0]
        #   load ss3 data for gene as pandas DataFrame
            ss3 = pd.read_csv(ss3_path, skiprows=3, names=columns, delim_whitespace=True)
        #   0 index the raptor results to conform to anvio convention :\
            ss3["codon_order_in_gene"] -= 1
        #   add gene column (used with 'reference' to uniquely map ss3 entries to saav entries)
            ss3["corresponding_gene_call"] = gene
        #   if the highest confidence for the 3 classes < self.ss3_confidence, the SAAV is classified as "U" for unknown
            l = [col for col in ss3.columns if "prob_" in col]
            ss3["ss3"] = ss3.apply(lambda row: row["ss3"] if any(row[l] > self.ss3_confidence) else "U", axis = 1)
        #   prob_genewide_X is the total number of AAs in the gene with secondary structure X
            ss3["ss3_genewide_H"] = len(ss3[ss3["ss3"] == "H"])
            ss3["ss3_genewide_E"] = len(ss3[ss3["ss3"] == "E"])
            ss3["ss3_genewide_C"] = len(ss3[ss3["ss3"] == "C"])
            ss3["ss3_genewide_U"] = len(ss3[ss3["ss3"] == "U"])
        #   The `AA` column (1-letter AA code) is redundant, we already have `reference` (3-letter AA code)
        #   prob_X are also dropped to cut down on saav_table_size, but code could be modified to retain them
            ss3 = ss3.drop(["AA"]+l, axis=1)
        #   merge with original dataframe
            return pd.merge(x,ss3)

        saav_table_grouped = self.saav_table.groupby("corresponding_gene_call")
        self.saav_table = saav_table_grouped.apply(calc_ss3_data_in_1gene)
        
    def append_8_class_structure(self):
        """
        RaptorX outputs a {}.all_in_one folder for each sequence it predicts structure for. All
        of these need to be placed into a folder self.raptor_repo. The secondary structure predictions
        for RaptorX are found in self.raptor_repo/{}.all_in_one/labeling/{}.ss8. This function uses
        this information from every gene in self.saav_table to construct 9 new columns:

        ss8 : ["H", "G", "I", "E", "B", "T", "S", "L", "U"]
            The most likely secondary structure. "H" = alpha helix, "E" = beta sheet, "C" = loop, ..., 
            and "U" = unknown. We classify the SAAV as "U" whenever the highest confidence score 
            attributed to the 3 structures is less than self.ss8_confidence.
        ss8_genewide_X : integer
            The number of amino acids (not SAAVs--you can count this yourself using the table) in the
            protein that are classified as X
        """
        
        columns = ("codon_order_in_gene","AA","ss8","prob_H","prob_G","prob_I","prob_E","prob_B","prob_T","prob_S","prob_L")

        def calc_ss8_data_in_1gene(x):
        #   get gene id of this groupby object, then find path of .ss8 file for that gene
            gene = x["corresponding_gene_call"].values[0]
            ss8_path = glob.glob(os.path.join(self.raptor_repo,"{}.all_in_one".format(gene),"labeling","*.ss8"))[0]
        #   load ss8 data for gene as pandas DataFrame
            ss8 = pd.read_csv(ss8_path, skiprows=3, names=columns, delim_whitespace=True)
        #   0 index the raptor results to conform to anvio convention :\
            ss8["codon_order_in_gene"] -= 1
        #   add gene column (used with 'reference' to uniquely map ss8 entries to saav entries)
            ss8["corresponding_gene_call"] = gene
        #   if the highest confidence for the 8 classes < self.prob_confidence, the SAAV is classified as "U" for unknown
            l = [col for col in ss8.columns if "prob_" in col]
            ss8["ss8"] = ss8.apply(lambda row: row["ss8"] if any(row[l] > self.ss8_confidence) else "U", axis = 1)
        #   ss8_genewide_X is the total number of AAs in the gene with secondary structure X
            ss8["ss8_genewide_H"] = len(ss8[ss8["ss8"] == "H"])
            ss8["ss8_genewide_G"] = len(ss8[ss8["ss8"] == "G"])
            ss8["ss8_genewide_I"] = len(ss8[ss8["ss8"] == "I"])
            ss8["ss8_genewide_E"] = len(ss8[ss8["ss8"] == "E"])
            ss8["ss8_genewide_B"] = len(ss8[ss8["ss8"] == "B"])
            ss8["ss8_genewide_T"] = len(ss8[ss8["ss8"] == "T"])
            ss8["ss8_genewide_S"] = len(ss8[ss8["ss8"] == "S"])
            ss8["ss8_genewide_L"] = len(ss8[ss8["ss8"] == "L"])
            ss8["ss8_genewide_U"] = len(ss8[ss8["ss8"] == "U"])
        #   The `AA` column (1-letter AA code) is redundant, we already have `reference` (3-letter AA code)
        #   ss8_X are also dropped to cut down on saav_table_size, but code could be modified to retain them
            ss8 = ss8.drop(["AA"]+l, axis=1)
        #   merge with original dataframe
            return pd.merge(x,ss8)
        
        saav_table_grouped = self.saav_table.groupby("corresponding_gene_call")
        self.saav_table = saav_table_grouped.apply(calc_ss8_data_in_1gene)
        
    def append_site_entropy(self, use_STP=None):
        """
        The site entropy is defined as S = - sum ( Pi * log2 Pi ), where i is the observed frequency of 
        AA i (i runs from 1 to M). For example, if a SAAV entry has 40x coverage, where 10 are Leu and 
        30 are Ile, P1=10 and P2=30.
        """
    #   create list of AAs
        AA_list = [u'Ala', u'Arg', u'Asn', u'Asp', u'Cys', u'Gln', u'Glu', u'Gly', u'His', u'Ile', u'Leu',
                    u'Lys', u'Met', u'Phe', u'Pro', u'Ser', u'Thr', u'Trp', u'Tyr', u'Val']
        if use_STP:
            AA_list.append(u'STP')

    #   convert SAAV counts in pandas DataFrame to numpy array (essential for speed, aka vectorized operations)
        x = self.saav_table[AA_list].as_matrix().astype(float)
        P = x / np.sum(x,axis=1)[:,np.newaxis]

    #   P = probability of an amino acid at a position in a sample
        P[P==0] = 1.0

    #   Site-specific entropy
        S = -np.sum(P*np.log(P)/np.log(self.entropy_log_base), axis=1)
        self.saav_table["site_entropy"] = S

    def append_site_rel_entropy(self, use_STP=None):
        """
        The relative site entropy is defined as S = - sum( Pij * log2 (Pij/Qi) ), where Pij is the probability
        of observing AA i in sample j, and Qi is the probability of observing AA i across all samples. This method
        is partially vectored, and is moderately expensive. With a SAAV table with 800,000 entries on a computer
        with moderate specs, this method takes 50 seconds.
        """
    #   create list of AAs
        AA_list = [u'Ala', u'Arg', u'Asn', u'Asp', u'Cys', u'Gln', u'Glu', u'Gly', u'His', u'Ile', u'Leu',
                    u'Lys', u'Met', u'Phe', u'Pro', u'Ser', u'Thr', u'Trp', u'Tyr', u'Val']
        if use_STP:
            AA_list.append(u'STP')

        def calc_rel_entropy_for_1position_for_all_samples(x):
        #   convert coverage data to array for vectorized operations
            count_matrix = x[AA_list].as_matrix().astype(float)
        #   P = probability of an amino acid at a position in a sample
            P = count_matrix / np.sum(count_matrix, axis=1)[:,np.newaxis]
        #   Q = probability of an amino acid at a position across all samples
            Q = np.sum(count_matrix,axis=0) / np.sum(count_matrix)
        #   This ratio is the argument of a log function
            P_over_Q = P/Q[np.newaxis,:]; 
        #   The log of 0 is -inf
            P_over_Q[P_over_Q==0] = 1.
        #   You can't divide 0 by 0
            P_over_Q[np.isnan(P_over_Q)] = 1.
        #   Site relative-entropy
            x["site_rel_entropy"] = np.sum(P*np.log(P_over_Q)/np.log(self.entropy_log_base), axis=1)
            return x

        saav_table_grouped = self.saav_table.groupby(["unique_pos_identifier"])
        self.saav_table = saav_table_grouped.apply(calc_rel_entropy_for_1position_for_all_samples)

    def get_all_append_methods(self):
        """
        This function returns a list of all the append methods. searches for 'append_' in the list of all
        methods and returns, as a list, all those containing 'append_'.
        """
        methods_list = [func for func in dir(TableOperations) if callable(getattr(TableOperations, func))] 
        append_methods = [func.replace("append_","") for func in methods_list if func[:7] == "append_"]
        return append_methods

    def sanity_check(self):
        """
        This checks that all of the append methods provided by the user are valid, and that any dependencies
        for these methods are satisfied. Additionally, if all the columns already exist for an append method,
        the method is not carried out.
        """
        for method_id in self.columns_to_append:

        #   all of the following method_ids are known to exist and have specific dependencies checked here.
            if method_id == "3_class_structure":
                cols_to_check = ["ss3","ss3_genewide_H","ss3_genewide_E","ss3_genewide_C"]
                if not self.raptor_repo:
                    raise ValueError("To run the {} method, you must supply the raptor-repo flag".format(method_id))
                if not self.ss3_confidence:
                    self.ss3_confidence = 0.5

            elif method_id == "8_class_structure":
                cols_to_check = ["ss8_genewide_H","ss8_genewide_G","ss8_genewide_I","ss8_genewide_E",
                                 "ss8_genewide_B","ss8_genewide_T","ss8_genewide_S","ss8_genewide_L","ss8"]
                if not self.raptor_repo:
                    raise ValueError("To run the {} method, you must supply the raptor-repo flag".format(method_id))
                if not self.ss8_confidence:
                    self.ss8_confidence = 0.5

            elif method_id == "solvent_accessibility":
                cols_to_check = ["solvent_acc"]
                if not self.raptor_repo:
                    raise ValueError("To run the {} method, you must supply the raptor-repo flag".format(method_id))
                if not self.solvent_acc_confidence:
                    self.solvent_acc_confidence = 0.5

        #   if method_id is not equal to one of the above, we check if the method exists
            else:
                cols_to_check = [method_id]
                if method_id not in self.list_of_append_methods:
                    raise ValueError("There exists no method for appending the method_id {}. Here is a list of column "\
                                     "ids that have defined methods:\n\n{}".format(method_id, self.list_of_append_methods))

        #   each of the above conditionals make a list of cols. This checks if these columns have already been added
            self.columns_to_append.remove(method_id) if self.do_all_columns_exist(cols_to_check) else None

    def do_all_columns_exist(self, column_list):
        """
        Returns True if all columns in columns_list already exist in self.saav_table, otherwise it returns
        False.
        """
        already_present = [col for col in column_list if col in self.saav_table.columns]
        return True if len(column_list)==len(already_present) else False

#============================================================================================================

class GeneMetrics():
    """
    This class clumps all of the methods used to get columns of gene_metrics in the class TableOperations. To add a new metric
    that should be added to the table, the function that calculates the metric should be added here. For example, if you want 
    the table to have a column called "new_col", add the following function to this class:

        def new_col(x):
            return np.sum(x["Ala"])

    It's values equal the number of Alanine reads observed for all the identified SAAVs in the gene (a nonsensical metric).
    All methods take as input, the subset of the SAAV table that only has SAAVs from one gene, i.e. x. Each method should return one
    number, the metric for that gene.
    """

    @staticmethod
    def density(x,extra): 
        total_saav_number = np.shape(x)[0]
        return total_saav_number / x["gene_length"].iloc[0] / extra["num_samples"]

